using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace UnityStableReference;

[SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking")]
[Generator]
public class StableWrapperSourceGenerator : IIncrementalGenerator
{
    // Define diagnostic descriptor
    private readonly DiagnosticDescriptor s_noTypeGuid = new(
        id: "SW001",
        title: "Type must have `TypeGuidAttribute`",
        messageFormat: "Type {0} must have `TypeGuidAttribute` for generating stable wrapper",
        category: "StableWrapper",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Check for assembly attribute first
        var hasAssemblyAttribute = context.CompilationProvider.Select((compilation, _) =>
            compilation.Assembly.GetAttributes()
                .Any(attr => attr.AttributeClass?.Name == "StableWrapperCodeGenAttribute"));

        var typeProvider = context.CompilationProvider.Select((compilation, _) =>
        {
            // Get types from current assembly and referenced assemblies
            var assemblies = compilation.References
                .Select(compilation.GetAssemblyOrModuleSymbol)
                .OfType<IAssemblySymbol>()
                .Append(compilation.Assembly)
            ;

            return assemblies.SelectMany(assembly => assembly.GlobalNamespace.GetAllTypes())
                .Where(type => type.GetAttributes().Any(a => a.AttributeClass?.Name == "StableWrapperCodeGenAttribute"))
            ;
        });

        context.RegisterSourceOutput(
            typeProvider.Combine(hasAssemblyAttribute),
            (context, tuple) =>
            {
                if (!tuple.Right) return; // Skip if assembly attribute not present
                GenerateStableWrapper(context, tuple.Left);
            });
    }

    private void GenerateStableWrapper(SourceProductionContext context, IEnumerable<INamedTypeSymbol> types)
    {
        var code = new StringBuilder("// <auto-generated/>");
        code.AppendLine();
        code.AppendLine("namespace __StableWrapper__");
        code.AppendLine("{");

        foreach (var type in types)
        {
             if (!type.GetAttributes().Any(attr => attr.AttributeClass?.Name == "TypeGuidAttribute"))
             {
                 context.ReportDiagnostic(Diagnostic.Create(
                     s_noTypeGuid,
                     type.Locations.FirstOrDefault(),
                     type.Name));
                 continue;
             }

             var guidAttr = type.GetAttributes() .First(attr => attr.AttributeClass?.Name == "TypeGuidAttribute");
             var guid = guidAttr.ConstructorArguments[0].Value?.ToString() ?.Replace("\"", "").Replace("-", "");
             code.AppendLine($$"""
                               [System.Serializable] public class StableWrapper_{{guid}} : Game.StableWrapper<{{type.ToDisplayString()}}> { }
                               """);
        }

        code.AppendLine("}");

        // Add the source to the context
        context.AddSource("StableWrapper.g.cs", code.ToString());
    }
}