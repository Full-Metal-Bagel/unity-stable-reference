using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace UnityStableReference;

[SuppressMessage("MicrosoftCodeAnalysisReleaseTracking", "RS2008:Enable analyzer release tracking")]
[Generator]
public class StableWrapperSourceGenerator : IIncrementalGenerator
{
    // Define diagnostic descriptor
    private readonly DiagnosticDescriptor s_noTypeGuid = new(
        id: "SW001",
        title: "Type must have `TypeGuidAttribute`",
        messageFormat: "Type {0} must have `TypeGuidAttribute` for generating stable wrapper",
        category: "StableWrapper",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Check for assembly attribute first
        var hasAssemblyAttribute = context.CompilationProvider.Select((compilation, _) =>
            compilation.Assembly.GetAttributes()
                .Any(attr => attr.AttributeClass?.Name == "StableWrapperCodeGenAttribute"));

        var typeProvider = context.CompilationProvider.Select((compilation, _) =>
        {
            // Get types from current assembly and referenced assemblies
            var assemblies = compilation.References
                .Select(compilation.GetAssemblyOrModuleSymbol)
                .OfType<IAssemblySymbol>()
                .Append(compilation.Assembly)
            ;

            return assemblies.SelectMany(assembly => assembly.GlobalNamespace.GetAllTypes())
                .Where(type => type.GetAttributes().Any(a => a.AttributeClass?.Name == "StableWrapperCodeGenAttribute"))
            ;
        });

        context.RegisterSourceOutput(
            typeProvider.Combine(hasAssemblyAttribute),
            (context, tuple) =>
            {
                if (!tuple.Right) return; // Skip if assembly attribute not present
                GenerateStableWrapper(context, tuple.Left);
            });
    }

    private void GenerateStableWrapper(SourceProductionContext context, IEnumerable<INamedTypeSymbol> types)
    {
        var code = new StringBuilder("// <auto-generated/>");
        code.AppendLine();
        code.AppendLine("namespace __StableWrapper__");
        code.AppendLine("{");

        foreach (var type in types)
        {
             if (!type.GetAttributes().Any(attr => attr.AttributeClass?.Name == "TypeGuidAttribute"))
             {
                 context.ReportDiagnostic(Diagnostic.Create(
                     s_noTypeGuid,
                     type.Locations.FirstOrDefault(),
                     type.Name));
                 continue;
             }

             var guidAttr = type.GetAttributes() .First(attr => attr.AttributeClass?.Name == "TypeGuidAttribute");
             var guid = guidAttr.ConstructorArguments[0].Value?.ToString() ?.Replace("\"", "").Replace("-", "");
             code.AppendLine($$"""
                               [System.Serializable] public class StableWrapper_{{guid}} : Game.StableWrapper<{{type.ToDisplayString()}}> { }
                               """);
        }

        code.AppendLine("}");

        // Add the source to the context
        context.AddSource("StableWrapper.g.cs", code.ToString());
    }
}

internal static class Extension
{
    public static string GetFullName(this TypeDeclarationSyntax node)
    {
        var namespaceName = GetNamespaceName(node);
        var className = node.Identifier.Text;
        return string.IsNullOrEmpty(namespaceName) ? className : $"{namespaceName}.{className}";
    }

    public static string GetFullName(this FieldDeclarationSyntax node)
    {
        var className = GetFullName((TypeDeclarationSyntax)node.Parent!);
        return $"{className}.{node.GetName()}";
    }

    public static string GetFullName(this MethodDeclarationSyntax node)
    {
        var className = GetFullName((TypeDeclarationSyntax)node.Parent!);
        return $"{className}.{node.GetName()}";
    }

    public static string GetDeclaringTypeFullName(this MemberDeclarationSyntax node)
    {
        return GetFullName((TypeDeclarationSyntax)node.Parent!);
    }

    public static string GetDeclaringTypeName(this MemberDeclarationSyntax node)
    {
        return ((TypeDeclarationSyntax)node.Parent!).Identifier.Text;
    }

    public static string GetName(this FieldDeclarationSyntax node)
    {
        return node.Declaration.Variables.First().Identifier.Text;
    }

    public static string GetName(this BaseTypeDeclarationSyntax node)
    {
        return node.Identifier.Text;
    }

    public static string GetName(this MethodDeclarationSyntax node)
    {
        return node.Identifier.Text;
    }

    public static string GetName(this PropertyDeclarationSyntax node)
    {
        return node.Identifier.Text;
    }

    public static string GetNamespaceName(this TypeDeclarationSyntax node)
    {
        var namespaceNode = node.Ancestors()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        if (namespaceNode == null)
        {
            return string.Empty;
        }

        return namespaceNode.Name.ToString();
    }

    public static string GetFullName(this TypeSyntax type, SemanticModel semanticModel)
    {
        var typeSymbol = ModelExtensions.GetTypeInfo(semanticModel, type).Type;
        return typeSymbol?.ToDisplayString() ?? type.ToString();
    }

    public static string GetTypeFullName(this FieldDeclarationSyntax node, SemanticModel semanticModel)
    {
        return node.Declaration.Type.GetFullName(semanticModel);
    }

    public static string GetTypeFullName(this PropertyDeclarationSyntax node, SemanticModel semanticModel)
    {
        return node.Type.GetFullName(semanticModel);
    }

    public static bool IsPublic(this MemberDeclarationSyntax node)
    {
        return node.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword));
    }

    public static bool IsReadOnly(this FieldDeclarationSyntax node)
    {
        return node.Modifiers.Any(m => m.IsKind(SyntaxKind.ReadOnlyKeyword));
    }

    public static bool HasGetMethod(this PropertyDeclarationSyntax node)
    {
        return node.AccessorList?.Accessors.Any(a => a.IsKind(SyntaxKind.GetAccessorDeclaration)) ?? false;
    }

    public static bool HasSetMethod(this PropertyDeclarationSyntax node)
    {
        return node.AccessorList?.Accessors.Any(a => a.IsKind(SyntaxKind.SetAccessorDeclaration)) ?? false;
    }

    private static bool HasPublicAccessor(this PropertyDeclarationSyntax node, SyntaxKind accessorKind)
    {
        if (!node.IsPublic()) return false;

        var accessor = node.AccessorList?.Accessors
            .FirstOrDefault(a => a.IsKind(accessorKind));

        if (accessor == null) return false;

        // If the accessor has no modifiers, it inherits the property's accessibility
        // If it has modifiers, check if it's explicitly public
        return !accessor.Modifiers.Any() ||
               accessor.Modifiers.Any(m => m.IsKind(SyntaxKind.PublicKeyword));
    }

    public static bool HasPublicGetMethod(this PropertyDeclarationSyntax node)
    {
        return HasPublicAccessor(node, SyntaxKind.GetAccessorDeclaration);
    }

    public static bool HasPublicSetMethod(this PropertyDeclarationSyntax node)
    {
        return HasPublicAccessor(node, SyntaxKind.SetAccessorDeclaration);
    }

    public static string GetGuid(this MemberDeclarationSyntax node)
    {
        var guidAttribute = node.AttributeLists
            .SelectMany(a => a.Attributes)
            .SingleOrDefault(attribute => attribute.Name.ToString() is "TypeGuid" or "PropertyGuid" or "FieldGuid" or "MethodGuid")
        ;
        return guidAttribute == null ? "" : guidAttribute.ArgumentList!.Arguments[0].ToString();
    }

    public static bool HasAttributeOf(this MemberDeclarationSyntax node, string attributeName)
    {
        return node.AttributeLists.SelectMany(al => al.Attributes).Any(attribute => attribute.Name.ToString() == attributeName);
    }

    public static IEnumerable<INamedTypeSymbol> GetAllTypes(this INamespaceSymbol @namespace)
    {
        // Get types directly in this namespace
        foreach (var type in @namespace.GetTypeMembers())
        {
            yield return type;

            // Get nested types
            foreach (var nestedType in type.GetTypeMembers())
            {
                yield return nestedType;
            }
        }

        // Recursively get types from child namespaces
        foreach (var childNamespace in @namespace.GetNamespaceMembers())
        {
            foreach (var type in GetAllTypes(childNamespace))
            {
                yield return type;
            }
        }
    }
}
